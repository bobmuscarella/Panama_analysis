names(tdata)[names(tdata)=='log.LDMC_AVI'] <- 'log.ldmc'
names(tdata)[names(tdata)=='log.LMALEAF_AVI'] <- 'log.lma'
names(tdata)[names(tdata)=='log.SEED_DRY'] <- 'log.seed'
names(tdata)[names(tdata)=='HEIGHT_AVG'] <- 'hmax'
tdata$plot <- ifelse(tdata$plot=='bci', 2, ifelse(tdata$plot=='cocoli', 1, 3))
traits <- c('wsg','log.ldmc','log.lma','log.seed','hmax')
##########################################
###  SURVIVAL ANALYSIS  -  MULTI PLOT ###
##########################################
library(jagsUI)
### Z-TRANSFORM DATA
z.score <- function (data, center=T) {
xm<- mean (data, na.rm=TRUE)
xsd<-sd(data, na.rm=TRUE)
if(center==F){xm <- 0}
xtrans<-(data-xm)/(2*xsd)
}
load("Panama_AnalysisData_12.9.15.RDA")
d <- tdata
###########################
#### Prepare data for input  ####
###########################
### Change names for ease
names(d)[names(d)=='WSG'] <- 'wsg'
names(d)[names(d)=='log.LDMC_AVI'] <- 'log.ldmc'
names(d)[names(d)=='log.LMALEAF_AVI'] <- 'log.lma'
names(d)[names(d)=='log.SEED_DRY'] <- 'log.seed'
names(d)[names(d)=='HEIGHT_AVG'] <- 'hmax'
# Work with one trait at a time....
#  for (i in 1:length(traits)) {
i <- 1
traits <- c('wsg','log.ldmc','log.lma','log.seed','hmax')
trait <- traits[i]
# Remove species with NA for trait value
d <- d[!is.na (d[,trait]),]
d <- droplevels(d)
######################################################################################
#### Standardize and Center coefficients (within plots, within size classes 10cm) ####
######################################################################################
##### Ontogenetic size class: Center / scale DBH within species, within size class #####
# size.classes <- tapply(d$dbh, paste(d$spcode, d$plot), quantile, 0.5)
# d$size.class <- ifelse(d$dbh <= size.classes[match(paste(d$spcode, d$plot), names(size.classes))], 1, 2)
# sp.size.class <- paste(d$spcode, d$size.class, sep=".")
# for (i in 1:length(unique(sp.size.class))){
#   tmp <- sort(unique(sp.size.class))[i]
#   d$log.dbh.z[sp.size.class %in% tmp] <- z.score(d$log.dbh[sp.size.class %in% tmp])
# }
# d$log.dbh.z[is.na(d$log.dbh.z)] <- 0
###### Generic size class: Center / scale DBH within species, within size class #####
cutoff <- (-100)  # Setting cutoff to neg value will put everything in 1 size class.
d$size.class <- ifelse(d$dbh <= cutoff, 1, 2)
d <- d[order(d$plot, d$spcode, d$size.class, d$id, d$census),]
### Center / scale other variableswithin size class
for (i in 1:2){
d$log.dbh.z[d$size.class %in% i] <- z.score(d$log.dbh[d$size.class %in% i])
d$log.nci.z[d$size.class %in% i] <- z.score(d$log.nci[d$size.class %in% i])
d$log.tnci.wsg.z[d$size.class %in% i] <- z.score(d$log.tnci.wsg[d$size.class %in% i])
d$log.tnci.log.ldmc.z[d$size.class %in% i] <- z.score(d$log.tnci.log.ldmc[d$size.class %in% i])
d$log.tnci.log.lma.z[d$size.class %in% i] <- z.score(d$log.tnci.log.lma[d$size.class %in% i])
d$log.tnci.log.seed.z[d$size.class %in% i] <- z.score(d$log.tnci.log.seed[d$size.class %in% i])
d$log.tnci.hmax.z[d$size.class %in% i] <- z.score(d$log.tnci.hmax[d$size.class %in% i])
}
### SET DIAM.z OF SINGLETON SPECIES (size classes) TO ZERO
d$log.dbh.z[is.na(d$log.dbh.z)] <- 0
sc <- 1
d <- d[d$size.class %in% sc,]
d <- d[,c('spcode','plot','census','survival','log.dbh.z','id','log.nci.z','days',
trait,
paste('log.tnci', trait, 'z', sep='.'))]
# SAMPLE DATA FOR EXPLORATORY...
# d <- d[sample(1:nrow(d), 5000),]
# d <- droplevels(d)
# rownames(d) <- NULL
# Make a speciesxplot column for correct indexing...
d$speciesxplot <- as.factor(paste(d$plot, d$spcode, sep='.'))
# Drop factors for correct indexing
d <- droplevels(d)
# Create an individual ID
d$indiv <- as.numeric(as.factor(d$id))
# Order for correct indexing
d <- d[order(d$indiv, d$census, d$spcode, d$plot),]
#################################
#### Organize the input data ####
#################################
data = list (
ntree = nrow(d),
nindiv = length(unique(d$id)),
nspecies = length(levels(d$speciesxplot)),
alive = as.numeric(d$survival),
days = as.numeric(d$days),
ncensus =  length(unique(paste(d$census, d$plot, sep=''))),
census = as.numeric(as.factor(paste(d$census, d$plot, sep=''))),
nci = as.numeric(d[,'log.nci.z']),
tnci = as.numeric(d[,paste('log.tnci.', trait, '.z', sep='')]),
dbh = as.numeric(d$log.dbh.z),
trait = z.score(tapply(d[,trait], d$speciesxplot, mean)),
indiv = d$indiv,
species = as.numeric(d$speciesxplot),
nplot = length(levels(as.factor(d$plot))),
plot = as.numeric(as.factor(substring(names(tapply(d[,trait], d$speciesxplot, mean)),1,3)))
)
### Add an indicator to set individual effect of non-rep indiv to zero
repindiv <- names(table(data$indiv))[table(data$indiv)>1]
data$indicator <- as.numeric(data$indiv %in% repindiv)
data$ntree
dim(d)
##########################################
###  SURVIVAL ANALYSIS  -  MULTI PLOT ###
##########################################
library(jagsUI)
### Z-TRANSFORM DATA
z.score <- function (data, center=T) {
xm<- mean (data, na.rm=TRUE)
xsd<-sd(data, na.rm=TRUE)
if(center==F){xm <- 0}
xtrans<-(data-xm)/(2*xsd)
}
### Running on PC???
pc <- T
#######################################
###  START HERE WITH PROCESSED DATA ###
#######################################
if(pc==T){
setwd("K:/Bob/Panama/GIT/Panama_analysis/DATA")
} else {
setwd("/Users/Bob/Projects/Postdoc/Panama/GIT/Panama_analysis/DATA")
}
load("Panama_AnalysisData_12.9.15.RDA")
d <- tdata
###########################
#### Prepare data for input  ####
###########################
### Change names for ease
names(d)[names(d)=='WSG'] <- 'wsg'
names(d)[names(d)=='log.LDMC_AVI'] <- 'log.ldmc'
names(d)[names(d)=='log.LMALEAF_AVI'] <- 'log.lma'
names(d)[names(d)=='log.SEED_DRY'] <- 'log.seed'
names(d)[names(d)=='HEIGHT_AVG'] <- 'hmax'
# Work with one trait at a time....
#  for (i in 1:length(traits)) {
i <- 1
traits <- c('wsg','log.ldmc','log.lma','log.seed','hmax')
trait <- traits[i]
# Remove species with NA for trait value
d <- d[!is.na (d[,trait]),]
d <- droplevels(d)
######################################################################################
#### Standardize and Center coefficients (within plots, within size classes 10cm) ####
######################################################################################
##### Ontogenetic size class: Center / scale DBH within species, within size class #####
# size.classes <- tapply(d$dbh, paste(d$spcode, d$plot), quantile, 0.5)
# d$size.class <- ifelse(d$dbh <= size.classes[match(paste(d$spcode, d$plot), names(size.classes))], 1, 2)
# sp.size.class <- paste(d$spcode, d$size.class, sep=".")
# for (i in 1:length(unique(sp.size.class))){
#   tmp <- sort(unique(sp.size.class))[i]
#   d$log.dbh.z[sp.size.class %in% tmp] <- z.score(d$log.dbh[sp.size.class %in% tmp])
# }
# d$log.dbh.z[is.na(d$log.dbh.z)] <- 0
###### Generic size class: Center / scale DBH within species, within size class #####
cutoff <- (100)  # Setting cutoff to neg value will put everything in 1 size class.
d$size.class <- ifelse(d$dbh <= cutoff, 1, 2)
d <- d[order(d$plot, d$spcode, d$size.class, d$id, d$census),]
pf=F
pc=F
### Center / scale other variableswithin size class
for (i in 1:2){
d$log.dbh.z[d$size.class %in% i] <- z.score(d$log.dbh[d$size.class %in% i])
d$log.nci.z[d$size.class %in% i] <- z.score(d$log.nci[d$size.class %in% i])
d$log.tnci.wsg.z[d$size.class %in% i] <- z.score(d$log.tnci.wsg[d$size.class %in% i])
d$log.tnci.log.ldmc.z[d$size.class %in% i] <- z.score(d$log.tnci.log.ldmc[d$size.class %in% i])
d$log.tnci.log.lma.z[d$size.class %in% i] <- z.score(d$log.tnci.log.lma[d$size.class %in% i])
d$log.tnci.log.seed.z[d$size.class %in% i] <- z.score(d$log.tnci.log.seed[d$size.class %in% i])
d$log.tnci.hmax.z[d$size.class %in% i] <- z.score(d$log.tnci.hmax[d$size.class %in% i])
}
d$log.dbh.z[is.na(d$log.dbh.z)] <- 0
sc <- 1
d <- d[d$size.class %in% sc,]
d <- d[,c('spcode','plot','census','survival','log.dbh.z','id','log.nci.z','days',
trait,
paste('log.tnci', trait, 'z', sep='.'))]
# SAMPLE DATA FOR EXPLORATORY...
# d <- d[sample(1:nrow(d), 5000),]
# d <- droplevels(d)
# rownames(d) <- NULL
# Make a speciesxplot column for correct indexing...
d$speciesxplot <- as.factor(paste(d$plot, d$spcode, sep='.'))
# Drop factors for correct indexing
d <- droplevels(d)
# Create an individual ID
d$indiv <- as.numeric(as.factor(d$id))
# Order for correct indexing
d <- d[order(d$indiv, d$census, d$spcode, d$plot),]
#################################
#### Organize the input data ####
#################################
data = list (
ntree = nrow(d),
nindiv = length(unique(d$id)),
nspecies = length(levels(d$speciesxplot)),
alive = as.numeric(d$survival),
days = as.numeric(d$days),
ncensus =  length(unique(paste(d$census, d$plot, sep=''))),
census = as.numeric(as.factor(paste(d$census, d$plot, sep=''))),
nci = as.numeric(d[,'log.nci.z']),
tnci = as.numeric(d[,paste('log.tnci.', trait, '.z', sep='')]),
dbh = as.numeric(d$log.dbh.z),
trait = z.score(tapply(d[,trait], d$speciesxplot, mean)),
indiv = d$indiv,
species = as.numeric(d$speciesxplot),
nplot = length(levels(as.factor(d$plot))),
plot = as.numeric(as.factor(substring(names(tapply(d[,trait], d$speciesxplot, mean)),1,3)))
)
### Add an indicator to set individual effect of non-rep indiv to zero
repindiv <- names(table(data$indiv))[table(data$indiv)>1]
data$indicator <- as.numeric(data$indiv %in% repindiv)
data$ntree
w <- data
#######################################
###  SURVIVAL ANALYSIS
###  ALL-PLOTS
###  ONLY NCI, DBH BY SIZE CLASS
###  Results in "K:/Bob/Panama/RESULTS/_12.17.15/survival/3level/"
#######################################
library(jagsUI)
### Z-TRANSFORM DATA
z.score <- function (data, center=T, scale=T) {
xm <- ifelse(center==T, mean (data, na.rm=TRUE), 0)
xsd <- ifelse(scale==T, sd(data, na.rm=TRUE), 2)
xtrans <- (data - xm) / (2 * xsd)
return(xtrans)
}
#######################################
###  START HERE WITH PROCESSED DATA ###
#######################################
setwd("K:/Bob/Panama/GIT/Panama_analysis/DATA")
load("Panama_AnalysisData_12.9.15.RDA")
###########################
#### Prepare data for input  ####
###########################
names(tdata)[names(tdata)=='WSG'] <- 'wsg'
names(tdata)[names(tdata)=='log.LDMC_AVI'] <- 'log.ldmc'
names(tdata)[names(tdata)=='log.LMALEAF_AVI'] <- 'log.lma'
names(tdata)[names(tdata)=='log.SEED_DRY'] <- 'log.seed'
names(tdata)[names(tdata)=='HEIGHT_AVG'] <- 'hmax'
tdata$plot <- ifelse(tdata$plot=='bci', 2, ifelse(tdata$plot=='cocoli', 1, 3))
#####################
#### Start Loop  ####
#####################
traits <- c('wsg','log.ldmc','log.lma','log.seed','hmax')
trt=1
trait <- traits[trt]
# Remove species with NA for trait value
d <- tdata[!is.na (tdata[,trait]),]
d <- droplevels(d)
######################################################################################
#### Standardize and Center coefficients (within plots, within size classes 10cm) ####
######################################################################################
###### Generic size class: Center / scale DBH within species, within size class #####
cutoff <- (100)  # Setting cutoff to neg value will put everything in 1 size class.
d$size.class <- ifelse(d$dbh <= cutoff, 1, 2)
### Center / scale other variableswithin size class
for (i in 1:2){
d$log.dbh.z[d$size.class %in% i] <- z.score(d$log.dbh[d$size.class %in% i])
d$log.nci.z[d$size.class %in% i] <- z.score(d$log.nci[d$size.class %in% i])
}
### SET DIAM.z OF SINGLETON SPECIES (size classes) TO ZERO
d$log.dbh.z[is.na(d$log.dbh.z)] <- 0
dp <- d
size=1
dps <- dp[dp$size.class %in% size,]
dps <- dps[,c('spcode','plot','size.class','census','survival','days','log.dbh.z','id','log.nci.z', trait)]
dps$speciesxplot <- as.factor(paste(dps$plot, dps$spcode, sep='.'))
# Drop factors for correct indexing
dps <- droplevels(dps)
# Create an individual ID
dps$indiv <- as.numeric(as.factor(dps$id))
# Order for correct indexing
dps <- dps[order(dps$indiv, dps$census, dps$spcode, dps$plot),]
#################################
#### Organize the input data ####
#################################
data = list (
ntree = nrow(dps),
nindiv = length(unique(dps$id)),
nspecies = length(unique(dps$speciesxplot)),
survival = as.numeric(dps$survival),
days = as.numeric(dps$days),
nci = as.numeric(dps[,'log.nci.z']),
ncensus = length(unique(paste(dps$census, dps$plot, sep=''))),
census = as.numeric(as.factor(paste(dps$census, dps$plot, sep=''))),
dbh = as.numeric(dps$log.dbh.z),
trait = z.score(tapply(dps[,trait], dps$speciesxplot, mean)),
indiv = dps$indiv,
species = as.numeric((dps$speciesxplot)),
nplot = length(levels(as.factor(dps$plot))),
plot = as.numeric(substring(names(tapply(dps[,trait], dps$speciesxplot, mean)),1,1))
)
### Add an indicator to set individual effect of non-rep indiv to zero
repindiv <- names(table(data$indiv))[table(data$indiv) > 1]
data$indicator <- as.numeric(data$indiv %in% repindiv)
data$trait
w$trait
data$trait
data$trait==w$trait
lapply(data, head)
names(data$trait)
data$plot
substring(data$trait,1,1,)
substring(data$trait,1,1)
names(data$trait)
substring(data$trait,1,2)
substring(data$trait,0,1)
substring(data$trait,1,1)
substring(names(data$trait), 1,1)
as.numeric(substring(names(data$trait), 1,1))
as.numeric(substring(names(data$trait), 1,1))==data$plot
tapply(dps[,trait], dps$speciesxplot, mean)
names(tapply(dps[,trait], dps$speciesxplot, mean))
sink("survival_3level_NCI.bug")
cat(" model {
for( i in 1:ntree ) {
alive[i] ~ dbern(t[i])
t[i] <- pow(z[i], days[i]/365.25)
logit(z[i]) <- beta.1[species[i]]
+ beta.2[species[i]] * nci[i]
+ beta.3[species[i]] * dbh[i]
+ indiv.effect[indiv[i]] * indicator[i]
+ census.effect[census[i]]
}
for( j in 1:nspecies ) {
beta.1[j] ~ dnorm(mu.beta.1[plot[j]] + beta.t.1[plot[j]] * trait[j], tau[1])
beta.2[j] ~ dnorm(mu.beta.2[plot[j]] + beta.t.2[plot[j]] * trait[j], tau[2])
beta.3[j] ~ dnorm(mu.beta.3[plot[j]], tau[3])
}
for( p in 1:nplot ) {
mu.beta.1[p] ~ dnorm(0, 1E-4)
mu.beta.2[p] ~ dnorm(0, 1E-4)
mu.beta.3[p] ~ dnorm(0, 1E-4)
beta.t.1[p] ~ dnorm(0, 1E-4)
beta.t.2[p] ~ dnorm(0, 1E-4)
}
for( c.a in 1:ncensus ) {
census.effect[c.a] ~ dnorm(0, 1E-4)
}
for( i.a in 1:nindiv ) {
indiv.effect[i.a] ~ dnorm(0, tau[4])
}
for( t in 1:3 ) {
tau[t] ~ dgamma(1E-3, 1E-3)
}
sigma <- 1 / sqrt(tau)
}"
, fill=TRUE)
sink()
# Set initial values
inits <- function (){
list(
beta.t.1 = rnorm(3),
beta.t.2 = rnorm(3),
mu.beta.1 = rnorm(3),
mu.beta.2 = rnorm(3),
mu.beta.3 = rnorm(3),
tau = rgamma(3, 1E3, 1E3))
}
params <- c('beta.t.1','beta.t.2','mu.beta.1','mu.beta.2','mu.beta.3','sigma')
adapt=10
iter=20
burn=10
iter=10
burn=0
thin=1
chains=1
modfile <- "survival_3level_NCI.bug"
mod <- jagsUI::jags(data, inits, params, modfile,
n.chains=chains, n.adapt=adapt, n.iter=iter,
n.burnin=burn, n.thin=thin, parallel=T)
sink("survival_3level_NCI.bug")
cat(" model {
for( i in 1:ntree ) {
alive[i] ~ dbern(t[i])
t[i] <- pow(z[i], days[i]/365.25)
logit(z[i]) <- beta.1[species[i]]
+ beta.2[species[i]] * nci[i]
+ beta.3[species[i]] * dbh[i]
+ indiv.effect[indiv[i]] * indicator[i]
+ census.effect[census[i]]
}
for( j in 1:nspecies ) {
beta.1[j] ~ dnorm(mu.beta.1[plot[j]] + beta.t.1[plot[j]] * trait[j], tau[1])
beta.2[j] ~ dnorm(mu.beta.2[plot[j]] + beta.t.2[plot[j]] * trait[j], tau[2])
beta.3[j] ~ dnorm(mu.beta.3[plot[j]], tau[3])
}
for( p in 1:nplot ) {
mu.beta.1[p] ~ dnorm(0, 1E-4)
mu.beta.2[p] ~ dnorm(0, 1E-4)
mu.beta.3[p] ~ dnorm(0, 1E-4)
beta.t.1[p] ~ dnorm(0, 1E-4)
beta.t.2[p] ~ dnorm(0, 1E-4)
}
for( c.a in 1:ncensus ) {
census.effect[c.a] ~ dnorm(0, 1E-4)
}
for( i.a in 1:nindiv ) {
indiv.effect[i.a] ~ dnorm(0, tau[4])
}
for( t in 1:4 ) {
tau[t] ~ dgamma(1E-3, 1E-3)
}
sigma <- 1 / sqrt(tau)
}"
, fill=TRUE)
sink()
################################################
### Set initial values, monitors, iterations and run model ###
################################################
# Set initial values
inits <- function (){
list(
beta.t.1 = rnorm(3),
beta.t.2 = rnorm(3),
mu.beta.1 = rnorm(3),
mu.beta.2 = rnorm(3),
mu.beta.3 = rnorm(3),
tau = rgamma(4, 1E3, 1E3))
}
mod <- jagsUI::jags(data, inits, params, modfile,
n.chains=chains, n.adapt=adapt, n.iter=iter,
n.burnin=burn, n.thin=thin, parallel=T)
setwd("K:/Bob/Panama/MODELS")
sink("survival_3level_NCI.bug")
cat(" model {
for( i in 1:ntree ) {
alive[i] ~ dbern(t[i])
t[i] <- pow(z[i], days[i]/365.25)
logit(z[i]) <- beta.1[species[i]]
+ beta.2[species[i]] * nci[i]
+ beta.3[species[i]] * dbh[i]
+ indiv.effect[indiv[i]] * indicator[i]
+ census.effect[census[i]]
}
for( j in 1:nspecies ) {
beta.1[j] ~ dnorm(mu.beta.1[plot[j]] + beta.t.1[plot[j]] * trait[j], tau[1])
beta.2[j] ~ dnorm(mu.beta.2[plot[j]] + beta.t.2[plot[j]] * trait[j], tau[2])
beta.3[j] ~ dnorm(mu.beta.3[plot[j]], tau[3])
}
for( p in 1:nplot ) {
mu.beta.1[p] ~ dnorm(0, 1E-4)
mu.beta.2[p] ~ dnorm(0, 1E-4)
mu.beta.3[p] ~ dnorm(0, 1E-4)
beta.t.1[p] ~ dnorm(0, 1E-4)
beta.t.2[p] ~ dnorm(0, 1E-4)
}
for( c.a in 1:ncensus ) {
census.effect[c.a] ~ dnorm(0, tau[4])
}
for( i.a in 1:nindiv ) {
indiv.effect[i.a] ~ dnorm(0, tau[5])
}
for( t in 1:5 ) {
tau[t] ~ dgamma(1E-3, 1E-3)
}
sigma <- 1 / sqrt(tau)
}"
, fill=TRUE)
sink()
inits <- function (){
list(
beta.t.1 = rnorm(3),
beta.t.2 = rnorm(3),
mu.beta.1 = rnorm(3),
mu.beta.2 = rnorm(3),
mu.beta.3 = rnorm(3),
tau = rgamma(5, 1E3, 1E3))
}
params <- c('beta.t.1','beta.t.2','mu.beta.1','mu.beta.2','mu.beta.3','sigma')
adapt
adapt=1
iter=2
iter=1
burn=0
thin=1
chains
mod <- jagsUI::jags(data, inits, params, modfile,
n.chains=chains, n.adapt=adapt, n.iter=iter,
n.burnin=burn, n.thin=thin, parallel=T)
#################################
#### Organize the input data ####
#################################
data = list (
ntree = nrow(dps),
nindiv = length(unique(dps$id)),
nspecies = length(unique(dps$speciesxplot)),
alive = as.numeric(dps$survival),
days = as.numeric(dps$days),
nci = as.numeric(dps[,'log.nci.z']),
ncensus = length(unique(paste(dps$census, dps$plot, sep=''))),
census = as.numeric(as.factor(paste(dps$census, dps$plot, sep=''))),
dbh = as.numeric(dps$log.dbh.z),
trait = z.score(tapply(dps[,trait], dps$speciesxplot, mean)),
indiv = dps$indiv,
species = as.numeric((dps$speciesxplot)),
nplot = length(levels(as.factor(dps$plot))),
plot = as.numeric(substring(names(tapply(dps[,trait], dps$speciesxplot, mean)),1,1))
)
### Add an indicator to set individual effect of non-rep indiv to zero
repindiv <- names(table(data$indiv))[table(data$indiv) > 1]
data$indicator <- as.numeric(data$indiv %in% repindiv)
mod <- jagsUI::jags(data, inits, params, modfile,
n.chains=chains, n.adapt=adapt, n.iter=iter,
n.burnin=burn, n.thin=thin, parallel=T)
dim(data)
length(data)
